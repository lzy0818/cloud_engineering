# Iris App

This is a simple [Streamlit](https://docs.streamlit.io/) application that loads a trained machine learning classifier on the [Iris dataset](https://archive.ics.uci.edu/ml/datasets/iris) using `scikit-learn` from disk, and provides an endpoint for performing inference on new data.

## Usage

This project requires an active python environment with the appropriate dependencies installed. It is recommended you do this in a virtual environment for the application. This project uses Poetry for environment management, but also includes a `requirements.txt` file for compatibility with any environment management tool.

```shell
poetry install
poetry shell

# OR...

python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
```

To use this application, you can run the `app.py` script with Streamlit, which will start the app server.

```bash
streamlit run src/app.py
```

By default, the script loads the classifier and preprocessed data from the `model.joblib` and `iris.joblib` files in the same directory as the application. You can modify these files to use your own data.

Once the server is running, you can access the Swagger UI by visiting `http://localhost` in your web browser. From there, you can test the `POST /predict` endpoint by providing a JSON payload with the `sepal_length`, `sepal_width`, `petal_length`, and `petal_width` fields.

## Docker

To run the Streamlit application in a Docker container, you can use the following commands:

```bash
docker build -t iris-app .
docker run -p 80:80 -v $(pwd)/artifacts:/app/artifacts iris-app

# OR

docker run -p 80:80 -v $(pwd)/../pipeline/artifacts:/app/artifacts iris-app
```

This will build a Docker image for the Streamlit application, and then run a container based on that image. The container will load the trained classifier and preprocessed data from the `model.joblib` and `iris.joblib` files in the `/app` directory, and expose the application on port `80`. The `-v` flag is used to mount the `/path/to/models` directory from the host machine to the `/app` directory inside the container, allowing the Streamlit application to access the model files generated by the pipeline.

## Errors on Apple Silicon

I was nearly driven to madness trying to troubleshoot this error, but it turns out Streamlit uses file-watching by default (monitors your project files and automatically reloads the app if files change). To do this, it uses a python library called `watchdog` which in turn uses a process called `inotify`. This library does not work when running x86_64-based containers on ARM-based hosts. So if you are on a newer Mac with Apple silicon (M1/M2), and building/running an image for x86_64 or amd64 platforms (e.g. building for ECS deployment), your docker run command will fail with something similar to:

```log
$ docker run --platform=linux/x86_64 -p 80:80 iris-app

<jemalloc>: MADV_DONTNEED does not work (memset will be used instead)
<jemalloc>: (This is the expected behaviour if you are running under QEMU)

Collecting usage statistics. To deactivate, set browser.gatherUsageStats to False.

Traceback (most recent call last):
  File "/usr/local/bin/streamlit", line 8, in <module>
    sys.exit(main())
  File "/usr/local/lib/python3.10/site-packages/click/core.py", line 1130, in __call__
    return self.main(*args, **kwargs)
  File "/usr/local/lib/python3.10/site-packages/click/core.py", line 1055, in main
    rv = self.invoke(ctx)
  File "/usr/local/lib/python3.10/site-packages/click/core.py", line 1657, in invoke
    return _process_result(sub_ctx.command.invoke(sub_ctx))
  File "/usr/local/lib/python3.10/site-packages/click/core.py", line 1404, in invoke
    return ctx.invoke(self.callback, **ctx.params)
  File "/usr/local/lib/python3.10/site-packages/click/core.py", line 760, in invoke
    return __callback(*args, **kwargs)
  File "/usr/local/lib/python3.10/site-packages/streamlit/web/cli.py", line 233, in main_run
    _main_run(target, args, flag_options=kwargs)
  File "/usr/local/lib/python3.10/site-packages/streamlit/web/cli.py", line 269, in _main_run
    bootstrap.run(file, command_line, args, flag_options)
  File "/usr/local/lib/python3.10/site-packages/streamlit/web/bootstrap.py", line 385, in run
    _install_pages_watcher(main_script_path)
  File "/usr/local/lib/python3.10/site-packages/streamlit/web/bootstrap.py", line 361, in _install_pages_watcher
    watch_dir(
  File "/usr/local/lib/python3.10/site-packages/streamlit/watcher/path_watcher.py", line 153, in watch_dir
    return _watch_path(
  File "/usr/local/lib/python3.10/site-packages/streamlit/watcher/path_watcher.py", line 128, in _watch_path
    watcher_class(
  File "/usr/local/lib/python3.10/site-packages/streamlit/watcher/event_based_path_watcher.py", line 92, in __init__
    path_watcher.watch_path(
  File "/usr/local/lib/python3.10/site-packages/streamlit/watcher/event_based_path_watcher.py", line 170, in watch_path
    folder_handler.watch = self._observer.schedule(
  File "/usr/local/lib/python3.10/site-packages/watchdog/observers/api.py", line 301, in schedule
    emitter.start()
  File "/usr/local/lib/python3.10/site-packages/watchdog/utils/__init__.py", line 92, in start
    self.on_thread_start()
  File "/usr/local/lib/python3.10/site-packages/watchdog/observers/inotify.py", line 119, in on_thread_start
    self._inotify = InotifyBuffer(path, self.watch.is_recursive)
  File "/usr/local/lib/python3.10/site-packages/watchdog/observers/inotify_buffer.py", line 37, in __init__
    self._inotify = Inotify(path, recursive)
  File "/usr/local/lib/python3.10/site-packages/watchdog/observers/inotify_c.py", line 167, in __init__
    Inotify._raise_error()
  File "/usr/local/lib/python3.10/site-packages/watchdog/observers/inotify_c.py", line 432, in _raise_error
    raise OSError(err, os.strerror(err))
OSError: [Errno 38] Function not implemented
```

The solution is/was to add `--server.fileWatcherType=none` to your startup command (you can do this in Dockerfile CMD instruction), **or** to just build/run on your native architecture without specifying `--platform` until you are ready to push to ECS.

This is documented in the [Docker Known Limitations](https://docs.docker.com/desktop/troubleshoot/known-issues/) page.

(I discovered this thanks to [this GitHub Issue](https://github.com/gorakhargosh/watchdog/issues/838))